{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"api/constructors/","title":"The <code>constructors</code> module","text":"<p>The <code>constructors</code> module holds a collection of convenience functions for expression type constructions and quantum operations (e.g. unitary and Hermitian operators, projectors) as well as trainable and non-trainable parameters as symbols.</p>"},{"location":"api/constructors/#qadence2_expressions.core.constructors.array_parameter","title":"<code>array_parameter(name, size)</code>","text":"<p>A non-trainable list of inputs.</p> PARAMETER DESCRIPTION <code>name</code> <p>Array of parameters name.</p> <p> TYPE: <code>str</code> </p> <code>size</code> <p>Array size.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Expression</code> <p>An array of parameters as sized symbol expression.</p> <p> TYPE: <code>Expression</code> </p> Source code in <code>qadence2_expressions/core/constructors.py</code> <pre><code>def array_parameter(name: str, size: int) -&gt; Expression:\n    \"\"\"A non-trainable list of inputs.\n\n    Args:\n        name (str): Array of parameters name.\n        size (int): Array size.\n\n    Returns:\n        Expression: An array of parameters as sized symbol expression.\n    \"\"\"\n\n    return symbol(name, size=size)\n</code></pre>"},{"location":"api/constructors/#qadence2_expressions.core.constructors.array_variable","title":"<code>array_variable(name, size)</code>","text":"<p>A trainable list of inputs.</p> PARAMETER DESCRIPTION <code>name</code> <p>Array of variables name.</p> <p> TYPE: <code>str</code> </p> <code>size</code> <p>Array size.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Expression</code> <p>An array of variables as sized symbol expression.</p> <p> TYPE: <code>Expression</code> </p> Source code in <code>qadence2_expressions/core/constructors.py</code> <pre><code>def array_variable(name: str, size: int) -&gt; Expression:\n    \"\"\"A trainable list of inputs.\n\n    Args:\n        name (str): Array of variables name.\n        size (int): Array size.\n\n    Returns:\n        Expression: An array of variables as sized symbol expression.\n    \"\"\"\n\n    return symbol(name, trainable=True, size=size)\n</code></pre>"},{"location":"api/constructors/#qadence2_expressions.core.constructors.function","title":"<code>function(name, *args)</code>","text":"<p>Symbolic representation of a function.</p> PARAMETER DESCRIPTION <code>name</code> <p>Function's name.</p> <p> TYPE: <code>str</code> </p> <code>args</code> <p>Remaining function arguments.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>Expression</code> <p>A function expression.</p> <p> TYPE: <code>Expression</code> </p> Source code in <code>qadence2_expressions/core/constructors.py</code> <pre><code>def function(name: str, *args: Any) -&gt; Expression:\n    \"\"\"Symbolic representation of a function.\n\n    Args:\n        name (str): Function's name.\n        args (Any): Remaining function arguments.\n\n    Returns:\n        Expression: A function expression.\n    \"\"\"\n\n    return Expression.function(name, *args)\n</code></pre>"},{"location":"api/constructors/#qadence2_expressions.core.constructors.parameter","title":"<code>parameter(name)</code>","text":"<p>A non-trainable input.</p> PARAMETER DESCRIPTION <code>name</code> <p>Parameter's name.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Expression</code> <p>A parameter as a symbol expression.</p> <p> TYPE: <code>Expression</code> </p> Source code in <code>qadence2_expressions/core/constructors.py</code> <pre><code>def parameter(name: str) -&gt; Expression:\n    \"\"\"A non-trainable input.\n\n    Args:\n        name (str): Parameter's name.\n\n    Returns:\n        Expression: A parameter as a symbol expression.\n    \"\"\"\n\n    return symbol(name)\n</code></pre>"},{"location":"api/constructors/#qadence2_expressions.core.constructors.parametric_operator","title":"<code>parametric_operator(name, *args, join=None, **attributes)</code>","text":"<p>A parametric operator.</p> <p>A parametric operator takes a list of positional arguments and generates a function that takes a list of indices (or a target and control tuples) and return an Expression.</p> <p>The <code>join</code> function is used to combine arguments of two parametric operators of the same kind acting on the same qubit support.</p> PARAMETER DESCRIPTION <code>name</code> <p>The operator's name.</p> <p> TYPE: <code>str</code> </p> <code>args</code> <p>The remaining operator arguments.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>join</code> <p>A function to join parameter arguments.</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>None</code> </p> <code>attributes</code> <p>Keywords used for compilation.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Callable</code> <p>A function to create a quantum operator.</p> <p> TYPE: <code>Callable</code> </p> Source code in <code>qadence2_expressions/core/constructors.py</code> <pre><code>def parametric_operator(\n    name: str, *args: Any, join: Callable | None = None, **attributes: Any\n) -&gt; Callable:\n    \"\"\"A parametric operator.\n\n    A parametric operator takes a list of positional arguments and\n    generates a function that takes a list of indices\n    (or a target and control tuples) and return an Expression.\n\n    The `join` function is used to combine arguments of two parametric\n    operators of the same kind acting on the same qubit support.\n\n    Args:\n        name (str): The operator's name.\n        args (Any): The remaining operator arguments.\n        join (Callable): A function to join parameter arguments.\n        attributes (Any): Keywords used for compilation.\n\n    Returns:\n        Callable: A function to create a quantum operator.\n    \"\"\"\n\n    def core(\n        *indices: Any,\n        target: tuple[int, ...] | None = None,\n        control: tuple[int, ...] | None = None,\n    ) -&gt; Expression:\n        return Expression.quantum_operator(\n            function(name, *args),\n            support=Support(*indices, target=target, control=control),\n            join=join,\n            **attributes,\n        )\n\n    return core\n</code></pre>"},{"location":"api/constructors/#qadence2_expressions.core.constructors.projector","title":"<code>projector(base, index)</code>","text":"<p>A projector operator.</p> <p>A projector is a function that takes a list of indices (or a target and control tuples) and return an Expression with the orthogonality property.</p> PARAMETER DESCRIPTION <code>base</code> <p>The computational basis to project on.</p> <p> TYPE: <code>str</code> </p> <code>index</code> <p>The index in the basis to project on.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Callable</code> <p>A function to create a quantum operator expression.</p> <p> TYPE: <code>Callable</code> </p> <p>Example: <pre><code>&gt;&gt;&gt; P0 = projector(\"Z\", \"0\")\n&gt;&gt;&gt; P1 = projector(\"Z\", \"1\")\n&gt;&gt;&gt; P0 * P0\nP0\n&gt;&gt;&gt; P0 * P1\n0\n</code></pre></p> Source code in <code>qadence2_expressions/core/constructors.py</code> <pre><code>def projector(base: str, index: str) -&gt; Callable:\n    \"\"\"A projector operator.\n\n    A projector is a function that takes a list of indices\n    (or a target and control tuples) and return an Expression with\n    the orthogonality property.\n\n    Args:\n        base (str): The computational basis to project on.\n        index (str): The index in the basis to project on.\n\n    Returns:\n        Callable: A function to create a quantum operator expression.\n\n    Example:\n    ```\n    &gt;&gt;&gt; P0 = projector(\"Z\", \"0\")\n    &gt;&gt;&gt; P1 = projector(\"Z\", \"1\")\n    &gt;&gt;&gt; P0 * P0\n    P0\n    &gt;&gt;&gt; P0 * P1\n    0\n    ```\n    \"\"\"\n\n    def core(\n        *indices: Any,\n        target: tuple[int, ...] | None = None,\n        control: tuple[int, ...] | None = None,\n    ) -&gt; Expression:\n        return Expression.quantum_operator(\n            symbol(f\"{base}{{{index}}}\"),\n            support=Support(*indices, target=target, control=control),\n            base=base,\n            is_projector=True,\n            is_hermitian=True,\n        )\n\n    return core\n</code></pre>"},{"location":"api/constructors/#qadence2_expressions.core.constructors.promote","title":"<code>promote(x)</code>","text":"<p>Type cast inputs as value type expressions.</p> PARAMETER DESCRIPTION <code>x</code> <p>A valid expression or numerical value. Numerical values are converted into <code>Value(x)</code> expressions.</p> <p> TYPE: <code>Expression | Numeric</code> </p> RETURNS DESCRIPTION <code>Expression</code> <p>A value type or expression.</p> <p> TYPE: <code>Expression</code> </p> Source code in <code>qadence2_expressions/core/constructors.py</code> <pre><code>def promote(x: Expression | Numeric) -&gt; Expression:\n    \"\"\"Type cast inputs as value type expressions.\n\n    Args:\n        x (Expression | Numeric): A valid expression or numerical value.\n         Numerical values are converted into `Value(x)` expressions.\n\n    Returns:\n        Expression: A value type or expression.\n    \"\"\"\n\n    return value(x) if not isinstance(x, Expression) else x\n</code></pre>"},{"location":"api/constructors/#qadence2_expressions.core.constructors.symbol","title":"<code>symbol(identifier, **attributes)</code>","text":"<p>Create a new symbol from the <code>identifier</code> if not protected.</p> PARAMETER DESCRIPTION <code>identifier</code> <p>Symbol's name.</p> <p> TYPE: <code>str</code> </p> Kwargs <p>attributes (Any): Keywords used as flags for compilation.</p> RETURNS DESCRIPTION <code>Expression</code> <p>A symbol type expression.</p> <p> TYPE: <code>Expression</code> </p> RAISES DESCRIPTION <code>SyntaxError</code> <p>If argument is expression protected.</p> Source code in <code>qadence2_expressions/core/constructors.py</code> <pre><code>def symbol(identifier: str, **attributes: Any) -&gt; Expression:\n    \"\"\"Create a new symbol from the `identifier` if not protected.\n\n    Args:\n        identifier (str): Symbol's name.\n\n    Kwargs:\n        attributes (Any): Keywords used as flags for compilation.\n\n    Returns:\n        Expression: A symbol type expression.\n\n    Raises:\n        SyntaxError: If argument is expression protected.\n    \"\"\"\n\n    if identifier in Environment.protected:\n        raise SyntaxError(f\"'{identifier}' is protected.\")\n\n    return Expression.symbol(identifier, **attributes)\n</code></pre>"},{"location":"api/constructors/#qadence2_expressions.core.constructors.unitary_hermitian_operator","title":"<code>unitary_hermitian_operator(name)</code>","text":"<p>A unitary Hermitian operator.</p> <p>A Hermitian operator is a function that takes a list of indices (or a target and control tuples) and return an Expression with hermitian and unitary properties.</p> PARAMETER DESCRIPTION <code>name</code> <p>The operator's name.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Callable</code> <p>A function to create a quantum operator expression.</p> <p> TYPE: <code>Callable</code> </p> <p>Example: <pre><code>&gt;&gt;&gt; A = unitary_hermitian_operator(\"A\")\n&gt;&gt;&gt; A(i) * A(i)\n1\n&gt;&gt;&gt; A(i) * A(j)  ; for i\u2260j\nA(i) * A(j)\n</code></pre></p> Source code in <code>qadence2_expressions/core/constructors.py</code> <pre><code>def unitary_hermitian_operator(name: str) -&gt; Callable:\n    \"\"\"A unitary Hermitian operator.\n\n    A Hermitian operator is a function that takes a list of indices\n    (or a target and control tuples) and return an Expression with\n    hermitian and unitary properties.\n\n    Args:\n        name (str): The operator's name.\n\n    Returns:\n        Callable: A function to create a quantum operator expression.\n\n    Example:\n    ```\n    &gt;&gt;&gt; A = unitary_hermitian_operator(\"A\")\n    &gt;&gt;&gt; A(i) * A(i)\n    1\n    &gt;&gt;&gt; A(i) * A(j)  ; for i\u2260j\n    A(i) * A(j)\n    ```\n    \"\"\"\n\n    def core(\n        *indices: Any,\n        target: tuple[int, ...] | None = None,\n        control: tuple[int, ...] | None = None,\n    ) -&gt; Expression:\n        return Expression.quantum_operator(\n            Expression.symbol(name),\n            support=Support(*indices, target=target, control=control),\n            is_hermitian=True,\n            is_unitary=True,\n        )\n\n    return core\n</code></pre>"},{"location":"api/constructors/#qadence2_expressions.core.constructors.value","title":"<code>value(x)</code>","text":"<p>Create a numerical expression from the value <code>x</code>.</p> PARAMETER DESCRIPTION <code>x</code> <p>Any numerical value.</p> <p> TYPE: <code>Numeric</code> </p> RETURNS DESCRIPTION <code>Expression</code> <p>An expression of type value.</p> <p> TYPE: <code>Expression</code> </p> RAISES DESCRIPTION <code>TypeError</code> <p>If the argument is non-numerical.</p> Source code in <code>qadence2_expressions/core/constructors.py</code> <pre><code>def value(x: Numeric) -&gt; Expression:\n    \"\"\"Create a numerical expression from the value `x`.\n\n    Args:\n        x (Numeric): Any numerical value.\n\n    Returns:\n        Expression: An expression of type value.\n\n    Raises:\n        TypeError: If the argument is non-numerical.\n    \"\"\"\n    if not isinstance(x, (complex, float, int)):\n        raise TypeError(\n            \"Input to 'value' constructor must be of type numeric, e.g.:'complex',\"\n            \" 'float', 'int', 'torch.Tensor', 'numpy.ndarray', etc. \"\n            f\"Got {type(x)}.\"\n        )\n\n    return Expression.value(x)\n</code></pre>"},{"location":"api/constructors/#qadence2_expressions.core.constructors.variable","title":"<code>variable(name)</code>","text":"<p>A trainable input.</p> PARAMETER DESCRIPTION <code>name</code> <p>Variable's name.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Expression</code> <p>A variable as a trainable symbol expression.</p> <p> TYPE: <code>Expression</code> </p> Source code in <code>qadence2_expressions/core/constructors.py</code> <pre><code>def variable(name: str) -&gt; Expression:\n    \"\"\"A trainable input.\n\n    Args:\n        name (str): Variable's name.\n\n    Returns:\n        Expression: A variable as a trainable symbol expression.\n    \"\"\"\n\n    return symbol(name, trainable=True)\n</code></pre>"},{"location":"api/environment/","title":"The <code>environment</code> module","text":"<p>The <code>environment</code> module defines an <code>Environment</code> type that plays a similar role as a context (or typing environment) for type checking systems. Here, it is a record of information for the qubit register and compilation directives.</p>"},{"location":"api/environment/#qadence2_expressions.core.environment.Environment","title":"<code>Environment</code>","text":"<p>An environment to hold register information and compiler directives.</p>"},{"location":"api/environment/#qadence2_expressions.core.environment.add_grid_options","title":"<code>add_grid_options(options)</code>","text":"<p>Add grid options to the Environment.</p> Source code in <code>qadence2_expressions/core/environment.py</code> <pre><code>def add_grid_options(options: dict[str, Any]) -&gt; None:\n    \"\"\"Add grid options to the Environment.\"\"\"\n    current = Environment.grid_options or {}\n    Environment.grid_options = {**current, **options}\n</code></pre>"},{"location":"api/environment/#qadence2_expressions.core.environment.add_qpu_directives","title":"<code>add_qpu_directives(directives)</code>","text":"<p>Add QPU directives to the Environment.</p> Source code in <code>qadence2_expressions/core/environment.py</code> <pre><code>def add_qpu_directives(directives: dict[str, Any]) -&gt; None:\n    \"\"\"Add QPU directives to the Environment.\"\"\"\n    current = Environment.directives or {}\n    Environment.directives = {**current, **directives}\n</code></pre>"},{"location":"api/environment/#qadence2_expressions.core.environment.add_settings","title":"<code>add_settings(settings)</code>","text":"<p>Add compilation settings to the Environment.</p> Source code in <code>qadence2_expressions/core/environment.py</code> <pre><code>def add_settings(settings: dict[str, Any]) -&gt; None:\n    \"\"\"Add compilation settings to the Environment.\"\"\"\n    current = Environment.settings or {}\n    Environment.settings = {**current, **settings}\n</code></pre>"},{"location":"api/environment/#qadence2_expressions.core.environment.get_grid_options","title":"<code>get_grid_options()</code>","text":"<p>Get grid options from the Environment.</p> Source code in <code>qadence2_expressions/core/environment.py</code> <pre><code>def get_grid_options() -&gt; dict[str, Any] | None:\n    \"\"\"Get grid options from the Environment.\"\"\"\n    return Environment.grid_options\n</code></pre>"},{"location":"api/environment/#qadence2_expressions.core.environment.get_grid_scale","title":"<code>get_grid_scale()</code>","text":"<p>Get grid scale in the Environment.</p> Source code in <code>qadence2_expressions/core/environment.py</code> <pre><code>def get_grid_scale() -&gt; float:\n    \"\"\"Get grid scale in the Environment.\"\"\"\n    return Environment.grid_scale\n</code></pre>"},{"location":"api/environment/#qadence2_expressions.core.environment.get_grid_type","title":"<code>get_grid_type()</code>","text":"<p>Get grid type from the Environment.</p> Source code in <code>qadence2_expressions/core/environment.py</code> <pre><code>def get_grid_type() -&gt; Literal[\"linear\", \"square\", \"triangular\"] | None:\n    \"\"\"Get grid type from the Environment.\"\"\"\n    return Environment.grid_type\n</code></pre>"},{"location":"api/environment/#qadence2_expressions.core.environment.get_number_qubits","title":"<code>get_number_qubits()</code>","text":"<p>Get the number of qubits from the Environment.</p> Source code in <code>qadence2_expressions/core/environment.py</code> <pre><code>def get_number_qubits() -&gt; int:\n    \"\"\"Get the number of qubits from the Environment.\"\"\"\n    return Environment.num_qubits\n</code></pre>"},{"location":"api/environment/#qadence2_expressions.core.environment.get_qpu_directives","title":"<code>get_qpu_directives()</code>","text":"<p>Get QPU directives from the Environment.</p> Source code in <code>qadence2_expressions/core/environment.py</code> <pre><code>def get_qpu_directives() -&gt; dict[str, Any] | None:\n    \"\"\"Get QPU directives from the Environment.\"\"\"\n    return Environment.directives\n</code></pre>"},{"location":"api/environment/#qadence2_expressions.core.environment.get_qubits_positions","title":"<code>get_qubits_positions()</code>","text":"<p>Get qubit positions from the Environment.</p> Source code in <code>qadence2_expressions/core/environment.py</code> <pre><code>def get_qubits_positions() -&gt; list[tuple[int, int]] | list[int] | None:\n    \"\"\"Get qubit positions from the Environment.\"\"\"\n    return Environment.qubit_positions\n</code></pre>"},{"location":"api/environment/#qadence2_expressions.core.environment.get_settings","title":"<code>get_settings()</code>","text":"<p>Get compilation settings from the Environment.</p> Source code in <code>qadence2_expressions/core/environment.py</code> <pre><code>def get_settings() -&gt; dict[str, Any] | None:\n    \"\"\"Get compilation settings from the Environment.\"\"\"\n    return Environment.settings\n</code></pre>"},{"location":"api/environment/#qadence2_expressions.core.environment.reset_ir_options","title":"<code>reset_ir_options()</code>","text":"<p>Reset Environment.</p> Source code in <code>qadence2_expressions/core/environment.py</code> <pre><code>def reset_ir_options() -&gt; None:\n    \"\"\"Reset Environment.\"\"\"\n    Environment.qubit_positions = None\n    Environment.grid_type = None\n    Environment.grid_scale = 1.0\n    Environment.num_qubits = 0\n    Environment.grid_options = None\n    Environment.directives = None\n    Environment.settings = None\n</code></pre>"},{"location":"api/environment/#qadence2_expressions.core.environment.set_grid_scale","title":"<code>set_grid_scale(s)</code>","text":"<p>Set grid scale in the Environment.</p> Source code in <code>qadence2_expressions/core/environment.py</code> <pre><code>def set_grid_scale(s: float) -&gt; None:\n    \"\"\"Set grid scale in the Environment.\"\"\"\n    Environment.grid_scale = s\n</code></pre>"},{"location":"api/environment/#qadence2_expressions.core.environment.set_grid_type","title":"<code>set_grid_type(grid)</code>","text":"<p>Set grid type in the Environment.</p> Source code in <code>qadence2_expressions/core/environment.py</code> <pre><code>def set_grid_type(grid: Literal[\"linear\", \"square\", \"triangular\"]) -&gt; None:\n    \"\"\"Set grid type in the Environment.\"\"\"\n    Environment.grid_type = grid\n</code></pre>"},{"location":"api/environment/#qadence2_expressions.core.environment.set_number_qubits","title":"<code>set_number_qubits(n)</code>","text":"<p>Set the number of qubits in the Environment if not defined in the register.</p> Source code in <code>qadence2_expressions/core/environment.py</code> <pre><code>def set_number_qubits(n: int) -&gt; None:\n    \"\"\"Set the number of qubits in the Environment if not defined in the register.\"\"\"\n    if Environment.qubit_positions and n != len(Environment.qubit_positions):\n        raise ValueError(\"Number of qubits already defined by the register.\")\n    Environment.num_qubits = n\n</code></pre>"},{"location":"api/environment/#qadence2_expressions.core.environment.set_qubits_positions","title":"<code>set_qubits_positions(pos)</code>","text":"<p>Set qubits positions in the Environment.</p> Source code in <code>qadence2_expressions/core/environment.py</code> <pre><code>def set_qubits_positions(pos: list[tuple[int, int]] | list[int]) -&gt; None:\n    \"\"\"Set qubits positions in the Environment.\"\"\"\n    Environment.qubit_positions = pos\n    set_number_qubits(len(pos))\n</code></pre>"},{"location":"api/expressions/","title":"The <code>expression</code> module","text":"<p>The <code>expression</code> module defines an <code>Expression</code> type as a symbolic representation for mathematical expressions together with arithmetic rules. It is syntactically constructed using S-Expressions in prefix notation where the ordered parameters are:</p> <ul> <li>A tag as a Python <code>Enum</code>: a token identifier for variables, functions or operations.</li> <li>Arguments: a set of arguments to define or be passed to the expression.</li> <li>Attributes: keyword arguments for symbolic evaluation and compilation directives.</li> </ul> <p>The <code>Expression</code> type defines constructors for four identifiers and operations variants:</p> <ul> <li><code>VALUE</code>: A value type to hold numerical <code>complex</code>, <code>float</code> or <code>int</code> primitive types.</li> <li><code>SYMBOL</code>: A symbol type for names definition.</li> <li><code>FN</code>: A variadic function type defined as a symbolic name and arguments.</li> <li><code>QUANTUM_OP</code>: A quantum operator type defined as an expression, a support of qubit resources and a collection of property attributes.</li> <li><code>ADD</code>: A variadic addition type as the sum of arguments.</li> <li><code>MUL</code>: A variadic multiplication type as the product of arguments.</li> <li><code>KRON</code>: A variadic multiplication type as the product of arguments with commutative rules.</li> <li><code>POW</code>: A power type as the exponentiation of a base and power arguments.</li> </ul>"},{"location":"api/expressions/#qadence2_expressions.core.expression.Expression","title":"<code>Expression(head, *args, **attributes)</code>","text":"<p>A symbolic representation of mathematical expressions.</p> <p>Besides arithmetic operations, the expression can contain classical functions such as sine, cosine, and logarithm, and abstract representations of quantum operators.</p> <p>Multiplication between quantum operators is stored as Kronecker products. Operators are ordered by qubit index, preserving the order when the qubit indices of two operators overlap. This ensures that operators acting on the same subspace are kept together, enhancing optimisation.</p> Source code in <code>qadence2_expressions/core/expression.py</code> <pre><code>def __init__(self, head: Expression.Tag, *args: Any, **attributes: Any) -&gt; None:\n    self.head = head\n    self.args = args\n    self.attrs = attributes\n</code></pre>"},{"location":"api/expressions/#qadence2_expressions.core.expression.Expression.dag","title":"<code>dag: Expression</code>  <code>property</code>","text":"<p>Returns the conjugated/dagger version of and expression.</p>"},{"location":"api/expressions/#qadence2_expressions.core.expression.Expression.max_index","title":"<code>max_index: int</code>  <code>cached</code> <code>property</code>","text":"<p>Returns the maximum qubit index present in the expression. An expression without quantum operators or covering all the qubits will return -1.</p> <p>Example: <pre><code>&gt;&gt;&gt; value(2).max_index\n-1\n&gt;&gt;&gt; (X() * Y(1)).max_index\n-1\n&gt;&gt;&gt; (X(0, 2) * Y(1)).max_index\n2\n</code></pre></p>"},{"location":"api/expressions/#qadence2_expressions.core.expression.Expression.subspace","title":"<code>subspace: Support | None</code>  <code>cached</code> <code>property</code>","text":"<p>Returns the total subspace coverage of an expression with quantum operators. If there are no quantum operators, the subspace is None. If controlled operators are present, it returns a controlled support if there is no overlap between targets and controls; otherwise, all indices are treated as targets.</p> <p>Example: <pre><code>&gt;&gt;&gt; value(1).subspace\nNone\n&gt;&gt;&gt; (X(1) + Y(2)).subspace\n[1 2]\n&gt;&gt;&gt; (X(target=(1,), control=(0,)) + Y(2)).subspace\n[1 2|0]\n&gt;&gt;&gt; (X(target=(1,), control=(2,)) + Y(2)).subspace\n[1 2]\n</code></pre></p>"},{"location":"api/expressions/#qadence2_expressions.core.expression.Expression.Tag","title":"<code>Tag</code>","text":"<p>               Bases: <code>Enum</code></p> <p>This auxiliar class allows the <code>Expression</code> to be represented as a tagged union.</p>"},{"location":"api/expressions/#qadence2_expressions.core.expression.Expression.__getitem__","title":"<code>__getitem__(index)</code>","text":"<p>Makes the arguments of the expression directly accessible through <code>expression[i]</code>.</p> Source code in <code>qadence2_expressions/core/expression.py</code> <pre><code>def __getitem__(self, index: int | slice) -&gt; Any:\n    \"\"\"Makes the arguments of the expression directly accessible through `expression[i]`.\"\"\"\n    return self.args[index]\n</code></pre>"},{"location":"api/expressions/#qadence2_expressions.core.expression.Expression.__pow__","title":"<code>__pow__(other)</code>","text":"<p>Power involving quantum operators always promote expression to quantum operators.</p> Source code in <code>qadence2_expressions/core/expression.py</code> <pre><code>def __pow__(self, other: object) -&gt; Expression:\n    \"\"\"Power involving quantum operators always promote expression to quantum operators.\"\"\"\n\n    if not isinstance(other, Expression | Numeric):\n        return NotImplemented\n\n    if isinstance(other, Numeric):\n        return self ** Expression.value(other)\n\n    # Numerical values are computed right away.\n    if self.is_value and other.is_value:\n        return Expression.value(self[0] ** other[0])\n\n    # Null power shortcut.\n    if other.is_zero:\n        return Expression.one()\n\n    # Identity power shortcut.\n    if other.is_one:\n        return self\n\n    # Power of power is a simple operation and can be evaluated here.\n    if (\n        self.is_quantum_operator\n        and self.get(\"is_hermitian\")\n        and self.get(\"is_unitary\")\n        and isinstance(other, Expression)\n        and other.is_value\n        and other[0] == int(other[0])\n    ):\n        power = int(other[0]) % 2\n        return self if power == 1 else Expression.one()\n\n    # Power of power is an simple operation and can be evaluated here.\n    # Whenever a quantum operator is present, the expression is promoted to\n    # a quantum operator.\n    if self.is_power:\n        return Expression.pow(self[0], self[1] * other).as_quantum_operator()\n\n    return Expression.pow(self, other).as_quantum_operator()\n</code></pre>"},{"location":"api/expressions/#qadence2_expressions.core.expression.Expression.add","title":"<code>add(*args)</code>  <code>classmethod</code>","text":"<p>In Expressions, addition is a variadic operation representing the sum of its arguments.</p> <p>Expression.add(a, b, c) == a + b + c</p> Source code in <code>qadence2_expressions/core/expression.py</code> <pre><code>@classmethod\ndef add(cls, *args: Expression) -&gt; Expression:\n    \"\"\"In Expressions, addition is a variadic operation representing the sum of its arguments.\n\n    Expression.add(a, b, c) == a + b + c\n    \"\"\"\n    return cls(cls.Tag.ADD, *args)\n</code></pre>"},{"location":"api/expressions/#qadence2_expressions.core.expression.Expression.as_quantum_operator","title":"<code>as_quantum_operator()</code>","text":"<p>Promotes and expression to a quantum operator.</p> <p>When a function takes a quantum operator as input, the function itself must be transformed into a quantum operator to preserve commutation properties. For instance,</p> <p>Example: <pre><code>&gt;&gt;&gt; exp(2) * exp(3)\nexp(5)\n&gt;&gt;&gt; exp(X(1)) * exp(Y(1))\nexp(X(1)) exp(Y(1))\n</code></pre></p> Source code in <code>qadence2_expressions/core/expression.py</code> <pre><code>def as_quantum_operator(self) -&gt; Expression:\n    \"\"\"Promotes and expression to a quantum operator.\n\n    When a function takes a quantum operator as input, the function itself must be transformed\n    into a quantum operator to preserve commutation properties. For instance,\n\n    Example:\n    ```\n    &gt;&gt;&gt; exp(2) * exp(3)\n    exp(5)\n    &gt;&gt;&gt; exp(X(1)) * exp(Y(1))\n    exp(X(1)) exp(Y(1))\n    ```\n    \"\"\"\n\n    subspace = self.subspace\n    if subspace:\n        return Expression.quantum_operator(self, subspace)\n\n    return self\n</code></pre>"},{"location":"api/expressions/#qadence2_expressions.core.expression.Expression.function","title":"<code>function(name, *args)</code>  <code>classmethod</code>","text":"<p>Symbolic representation of a function. The <code>name</code> indicates the function identifier, the remaining arguments are used as the function arguments.</p> <pre><code>Expression.function(\"sin\", 1.57) =&gt; sin(1.57)\n</code></pre> PARAMETER DESCRIPTION <code>name</code> <p>The function name.</p> <p> TYPE: <code>str</code> </p> <code>args</code> <p>The arguments to be passed to the function.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>Expression</code> <p>A <code>Function(Symbol('name'), args...)</code> expression.</p> Source code in <code>qadence2_expressions/core/expression.py</code> <pre><code>@classmethod\ndef function(cls, name: str, *args: Any) -&gt; Expression:\n    \"\"\"\n    Symbolic representation of a function. The `name` indicates the function identifier, the\n    remaining arguments are used as the function arguments.\n\n        Expression.function(\"sin\", 1.57) =&gt; sin(1.57)\n\n    Args:\n        name: The function name.\n        args: The arguments to be passed to the function.\n\n    Returns:\n        A `Function(Symbol('name'), args...)` expression.\n    \"\"\"\n    return cls(cls.Tag.FN, cls.symbol(name), *args)\n</code></pre>"},{"location":"api/expressions/#qadence2_expressions.core.expression.Expression.get","title":"<code>get(attribute, default=None)</code>","text":"<p>Retrieve the value of the chosen <code>attribute</code> if it exists, or return the <code>default</code> value if it doesn't.</p> Source code in <code>qadence2_expressions/core/expression.py</code> <pre><code>def get(self, attribute: str, default: Any | None = None) -&gt; Any:\n    \"\"\"Retrieve the value of the chosen `attribute` if it exists, or return the `default` value\n    if it doesn't.\n    \"\"\"\n    return self.attrs.get(attribute, default)\n</code></pre>"},{"location":"api/expressions/#qadence2_expressions.core.expression.Expression.kron","title":"<code>kron(*args)</code>  <code>classmethod</code>","text":"<p>In Expressions, the Kronecker product is a variadic operation representing the multiplication of its arguments applying commutative rules. When the qubit indices of two operators overlap, the order is preserved. Otherwise, the operators are ordered by index, with operators acting on the same qubits placed next to each other.</p> <pre><code>Expression.kron(X(1), X(2), Y(1)) == X(1)Y(1) \u2297  X(2)\n</code></pre> Source code in <code>qadence2_expressions/core/expression.py</code> <pre><code>@classmethod\ndef kron(cls, *args: Expression) -&gt; Expression:\n    \"\"\"In Expressions, the Kronecker product is a variadic operation representing the\n    multiplication of its arguments applying commutative rules. When the qubit indices of two\n    operators overlap, the order is preserved. Otherwise, the operators are ordered by index,\n    with operators acting on the same qubits placed next to each other.\n\n        Expression.kron(X(1), X(2), Y(1)) == X(1)Y(1) \u2297  X(2)\n    \"\"\"\n\n    return cls(cls.Tag.KRON, *args)\n</code></pre>"},{"location":"api/expressions/#qadence2_expressions.core.expression.Expression.mul","title":"<code>mul(*args)</code>  <code>classmethod</code>","text":"<p>In Expressions, multiplication is a variadic operation representing the product of its arguments.</p> <pre><code>Expression.mul(a, b, c) == a * b * c\n</code></pre> Source code in <code>qadence2_expressions/core/expression.py</code> <pre><code>@classmethod\ndef mul(cls, *args: Expression) -&gt; Expression:\n    \"\"\"In Expressions, multiplication is a variadic operation representing the product of its\n    arguments.\n\n        Expression.mul(a, b, c) == a * b * c\n    \"\"\"\n\n    return cls(cls.Tag.MUL, *args)\n</code></pre>"},{"location":"api/expressions/#qadence2_expressions.core.expression.Expression.one","title":"<code>one()</code>  <code>classmethod</code>","text":"<p>Used to represent both, the numerical value <code>1</code> and the identity operator.</p> RETURNS DESCRIPTION <code>Expression</code> <p>An <code>Value(1)</code> expression.</p> Source code in <code>qadence2_expressions/core/expression.py</code> <pre><code>@classmethod\ndef one(cls) -&gt; Expression:\n    \"\"\"Used to represent both, the numerical value `1` and the identity operator.\n\n    Returns:\n        An `Value(1)` expression.\n    \"\"\"\n    return cls.value(1)\n</code></pre>"},{"location":"api/expressions/#qadence2_expressions.core.expression.Expression.pow","title":"<code>pow(base, power)</code>  <code>classmethod</code>","text":"<p>Define a power expression.</p> <p>Expression.power(a, b) == a**b</p> Source code in <code>qadence2_expressions/core/expression.py</code> <pre><code>@classmethod\ndef pow(cls, base: Expression, power: Expression) -&gt; Expression:\n    \"\"\"Define a power expression.\n\n    Expression.power(a, b) == a**b\n    \"\"\"\n\n    return cls(cls.Tag.POW, base, power)\n</code></pre>"},{"location":"api/expressions/#qadence2_expressions.core.expression.Expression.quantum_operator","title":"<code>quantum_operator(expr, support, **attributes)</code>  <code>classmethod</code>","text":"<p>To turn an expression into a quantum operator, specify the support it acts on. Attributes like <code>is_projector</code> [bool], <code>is_hermitian</code> [bool], <code>is_unitary</code> [bool], <code>is_dagger</code> [bool], and <code>join</code> [callable] indicate how the operator behaves during evaluation.</p> <p>A parametric quantum operator is a function wrapped in a quantum operator. The <code>join</code> attribute is used to combine the arguments of two parametric operators.</p> PARAMETER DESCRIPTION <code>expr</code> <p>An expression that describes the operator. If <code>expr</code> is a symbol, it represents a generic gate like Pauli and Clifford gates. If <code>expr</code> is a function, it represents a parametric operator. Power expressions can be used to represent unitary evolution operators.</p> <p> TYPE: <code>Expression</code> </p> <code>support</code> <p>The qubit indices to what the operator is applied.</p> <p> TYPE: <code>Support</code> </p> Kwargs <p>Keyword arguments are used primarily to symbolic evaluation. Examples of keywords are:     - <code>is_projector</code> [bool]     - <code>is_hermitian</code> [bool]     - <code>is_unitary</code> [bool]     - <code>is_dagger</code> [bool]     - <code>join</code> [callable]</p> <p>The keyword, <code>join</code> is used with parametric operators. Whe two parametric operator of the same kind action on the same subspace are muliplied, the <code>join</code> is used to combine their arguments.</p> RETURNS DESCRIPTION <code>Expression</code> <p>An expression of type <code>QuantumOperator</code>.</p> Source code in <code>qadence2_expressions/core/expression.py</code> <pre><code>@classmethod\ndef quantum_operator(cls, expr: Expression, support: Support, **attributes: Any) -&gt; Expression:\n    \"\"\"To turn an expression into a quantum operator, specify the support it acts on. Attributes\n    like `is_projector` [bool], `is_hermitian` [bool], `is_unitary` [bool], `is_dagger` [bool],\n    and `join` [callable] indicate how the operator behaves during evaluation.\n\n    A parametric quantum operator is a function wrapped in a quantum operator. The `join`\n    attribute is used to combine the arguments of two parametric operators.\n\n    Args:\n        expr: An expression that describes the operator. If `expr` is a symbol, it represents\n            a generic gate like Pauli and Clifford gates. If `expr` is a function, it represents\n            a parametric operator. Power expressions can be used to represent unitary evolution\n            operators.\n        support: The qubit indices to what the operator is applied.\n\n    Kwargs:\n        Keyword arguments are used primarily to symbolic evaluation. Examples of keywords are:\n            - `is_projector` [bool]\n            - `is_hermitian` [bool]\n            - `is_unitary` [bool]\n            - `is_dagger` [bool]\n            - `join` [callable]\n\n        The keyword, `join` is used with parametric operators. Whe two parametric operator of\n        the same kind action on the same subspace are muliplied, the `join` is used to combine\n        their arguments.\n\n    Returns:\n        An expression of type `QuantumOperator`.\n    \"\"\"\n\n    return cls(cls.Tag.QUANTUM_OP, expr, support, **attributes)\n</code></pre>"},{"location":"api/expressions/#qadence2_expressions.core.expression.Expression.symbol","title":"<code>symbol(identifier, **attributes)</code>  <code>classmethod</code>","text":"<p>Create a symbol from the identifier.</p> PARAMETER DESCRIPTION <code>identifier</code> <p>A string used as the symbol name.</p> <p> TYPE: <code>str</code> </p> Kwargs <p>Keyword arguments are used as flags for compilation steps. The valid flags are defined in Qadence2-IR.</p> RETURNS DESCRIPTION <code>Expression</code> <p>A <code>Symbol('identifier')</code> expression.</p> Source code in <code>qadence2_expressions/core/expression.py</code> <pre><code>@classmethod\ndef symbol(cls, identifier: str, **attributes: Any) -&gt; Expression:\n    \"\"\"Create a symbol from the identifier.\n\n    Args:\n        identifier: A string used as the symbol name.\n\n    Kwargs:\n        Keyword arguments are used as flags for compilation steps.\n        The valid flags are defined in Qadence2-IR.\n\n    Returns:\n        A `Symbol('identifier')` expression.\n    \"\"\"\n    return cls(cls.Tag.SYMBOL, identifier, **attributes)\n</code></pre>"},{"location":"api/expressions/#qadence2_expressions.core.expression.Expression.value","title":"<code>value(x)</code>  <code>classmethod</code>","text":"<p>Promote a numerical value (complex, float, int) to an expression.</p> PARAMETER DESCRIPTION <code>x</code> <p>A numerical value.</p> <p> TYPE: <code>Numeric</code> </p> RETURNS DESCRIPTION <code>Expression</code> <p>A <code>Value(x)</code> expression.</p> Source code in <code>qadence2_expressions/core/expression.py</code> <pre><code>@classmethod\ndef value(cls, x: Numeric) -&gt; Expression:\n    \"\"\"Promote a numerical value (complex, float, int) to an expression.\n\n    Args:\n        x: A numerical value.\n\n    Returns:\n        A `Value(x)` expression.\n    \"\"\"\n\n    return cls(cls.Tag.VALUE, float(x)) if isinstance(x, int) else cls(cls.Tag.VALUE, x)\n</code></pre>"},{"location":"api/expressions/#qadence2_expressions.core.expression.Expression.zero","title":"<code>zero()</code>  <code>classmethod</code>","text":"<p>Used to represent both, the numerical value <code>0</code> and the null operator.</p> RETURNS DESCRIPTION <code>Expression</code> <p>An <code>Value(0)</code> expression.</p> Source code in <code>qadence2_expressions/core/expression.py</code> <pre><code>@classmethod\ndef zero(cls) -&gt; Expression:\n    \"\"\"Used to represent both, the numerical value `0` and the null operator.\n\n    Returns:\n        An `Value(0)` expression.\n    \"\"\"\n    return cls.value(0)\n</code></pre>"},{"location":"api/expressions/#qadence2_expressions.core.expression.evaluate_kron","title":"<code>evaluate_kron(expr)</code>","text":"<p>Evaluate Kronecker product expressions.</p> Source code in <code>qadence2_expressions/core/expression.py</code> <pre><code>def evaluate_kron(expr: Expression) -&gt; Expression:\n    \"\"\"Evaluate Kronecker product expressions.\"\"\"\n\n    lhs = expr[0]\n    for rhs in expr[1:]:\n        # Single operators multiplication, A \u2297 B\n        if lhs.is_quantum_operator and rhs.is_quantum_operator:\n            lhs = evaluate_kronop(lhs, rhs)\n\n        # Left associativity, A \u2297 (B \u2297 C \u2297 D) = (A \u2297 B \u2297 C \u2297 D)\n        elif lhs.is_quantum_operator and rhs.is_kronecker_product:\n            lhs = evaluate_kronleft(lhs, rhs)\n\n        # Right associativity, (A \u2297 B \u2297 C) \u2297 D = (A \u2297 B \u2297 C \u2297 D)\n        elif lhs.is_kronecker_product and rhs.is_quantum_operator:\n            lhs = evaluate_kronright(lhs, rhs)\n\n        # Combine two Kronecker products, (A \u2297 B) \u2297 (C \u2297 D) = (A \u2297 B \u2297 C \u2297 D)\n        elif lhs.is_kronecker_product and rhs.is_kronecker_product:\n            lhs = evaluate_kronjoin(lhs, rhs)\n\n        else:\n            raise NotImplementedError\n\n    return lhs  # type: ignore\n</code></pre>"},{"location":"api/expressions/#qadence2_expressions.core.expression.evaluate_kronjoin","title":"<code>evaluate_kronjoin(lhs, rhs)</code>","text":"<p>Evaluate the Kronecker product between a LHS=quantum operators and a RHS=Kronecker product.</p> Source code in <code>qadence2_expressions/core/expression.py</code> <pre><code>def evaluate_kronjoin(lhs: Expression, rhs: Expression) -&gt; Expression:\n    \"\"\"Evaluate the Kronecker product between a LHS=quantum operators and a RHS=Kronecker\n    product.\n    \"\"\"\n\n    if not (lhs.is_kronecker_product or rhs.is_kronecker_product):\n        raise SyntaxError(\"Only defined for LHS and RHS both Kronecker product.\")\n\n    result = lhs\n    for term in rhs.args:\n        result = evaluate_kron(Expression.kron(result, term))\n\n    return result\n</code></pre>"},{"location":"api/expressions/#qadence2_expressions.core.expression.evaluate_kronleft","title":"<code>evaluate_kronleft(lhs, rhs)</code>","text":"<p>Left associativity of the Kronecker product.</p> <p>Evaluate the Kronecker product between a LHS=quantum operators and a RHS=Kronecker product.</p> Source code in <code>qadence2_expressions/core/expression.py</code> <pre><code>def evaluate_kronleft(lhs: Expression, rhs: Expression) -&gt; Expression:\n    \"\"\"Left associativity of the Kronecker product.\n\n    Evaluate the Kronecker product between a LHS=quantum operators and a RHS=Kronecker product.\n    \"\"\"\n\n    if not (lhs.is_quantum_operator or rhs.is_kronecker_product):\n        raise SyntaxError(\"Only defined for a quantum operator and a Kronecker product.\")\n\n    args = rhs.args\n\n    # Using a insertion-sort-like to add the LHS term in the the RHS product.\n    for i, rhs_arg in enumerate(args):\n        if rhs_arg.subspace == lhs.subspace:  # type: ignore\n            ii = i + 1\n\n            result = evaluate_kronop(lhs, rhs_arg)\n\n            if result.is_one:\n                args = (*args[:i], *args[ii:])\n\n            elif result.is_kronecker_product:\n                args = (*args[:i], *result.args, *args[ii:])\n\n            else:\n                args = (*args[:i], result, *args[ii:])\n\n            break\n\n        if rhs_arg.subspace &gt; lhs.subspace or rhs_arg.subspace.overlap_with(lhs.subspace):\n            args = (*args[:i], lhs, *args[i:])\n            break\n\n        if i == len(args) - 1:\n            args = (lhs, *args)\n\n    if not args:\n        return Expression.one()\n\n    return args[0] if len(args) == 1 else Expression.kron(*args)  # type: ignore\n</code></pre>"},{"location":"api/expressions/#qadence2_expressions.core.expression.evaluate_kronop","title":"<code>evaluate_kronop(lhs, rhs)</code>","text":"<p>Evaluate the Kronecker product between two quantum operators.</p> Source code in <code>qadence2_expressions/core/expression.py</code> <pre><code>def evaluate_kronop(lhs: Expression, rhs: Expression) -&gt; Expression:\n    \"\"\"Evaluate the Kronecker product between two quantum operators.\"\"\"\n\n    if not (lhs.is_quantum_operator or rhs.is_quantum_operator):\n        raise SyntaxError(\"Operation only valid for LHS and RHS both quantum operators.\")\n\n    # Multiplication of unitary Hermitian operators acting on the the same subspace.\n    if lhs == rhs and (lhs.get(\"is_hermitian\") and lhs.get(\"is_unitary\")):\n        return Expression.one()\n\n    # General multiplications of operators acting on the same subspace.\n    if lhs.subspace == rhs.subspace:\n        if lhs.get(\"is_projector\") and rhs.get(\"is_projector\"):\n            return lhs if lhs[0] == rhs[0] else Expression.zero()\n\n        if lhs[0].is_function and rhs[0].is_function and lhs[0][0] == rhs[0][0] and lhs.get(\"join\"):\n            res = lhs.get(\"join\")(\n                lhs[0], rhs[0], lhs.get(\"is_dagger\", False), rhs.get(\"is_dagger\", False)\n            )\n            return (  # type: ignore\n                res\n                if res.is_zero or res.is_one\n                else Expression.quantum_operator(res, lhs[1], **lhs.attrs)\n            )\n\n        # Simplify the multiplication of unitary Hermitian operators with fractional\n        # power, e.g., `\u221aX() * \u221aX() == X()`.\n        if (\n            lhs[0].is_power\n            and rhs[0].is_power\n            and lhs[0][0] == rhs[0][0]  # both are the same operator\n            and (lhs[0][0].get(\"is_hermitian\") and lhs[0][0].get(\"is_unitary\"))\n        ):\n            return lhs[0][0] ** (lhs[0][1] + rhs[0][1])  # type: ignore\n\n    # Order the operators by subspace.\n    if lhs.subspace &lt; rhs.subspace or lhs.subspace.overlap_with(  # type: ignore\n        rhs.subspace  # type: ignore\n    ):\n        return Expression.kron(lhs, rhs)\n\n    return Expression.kron(rhs, lhs)\n</code></pre>"},{"location":"api/expressions/#qadence2_expressions.core.expression.evaluate_kronright","title":"<code>evaluate_kronright(lhs, rhs)</code>","text":"<p>Right associativity of the Kronecker product.</p> <p>Evaluate the Kronecker product between a LHS=quantum operators and a RHS=Kronecker product.</p> Source code in <code>qadence2_expressions/core/expression.py</code> <pre><code>def evaluate_kronright(lhs: Expression, rhs: Expression) -&gt; Expression:\n    \"\"\"Right associativity of the Kronecker product.\n\n    Evaluate the Kronecker product between a LHS=quantum operators and a RHS=Kronecker product.\n    \"\"\"\n\n    if not (lhs.is_kronecker_product or rhs.is_quantum_operator):\n        raise SyntaxError(\"Only defined for a Kronecker product and a quantum operator.\")\n\n    args = lhs.args\n\n    # Using a insertion-sort-like to add the RHS term in the the LHS product.\n    for i in range(len(args) - 1, -1, -1):\n        ii = i + 1\n\n        if args[i].subspace == rhs.subspace:  # type: ignore\n            result = evaluate_kronop(args[i], rhs)\n\n            if result.is_one:\n                args = (*args[:i], *args[ii:])\n\n            elif result.is_kronecker_product:\n                args = (*args[:i], *result.args, *args[ii:])\n\n            else:\n                args = (*args[:i], result, *args[ii:])\n\n            break\n\n        if args[i].subspace &lt; rhs.subspace or args[i].subspace.overlap_with(rhs.subspace):\n            args = (*args[:ii], rhs, *args[ii:])\n            break\n\n        if i == 0:\n            args = (rhs, *args)\n\n    if not args:\n        return Expression.one()\n\n    return args[0] if len(args) == 1 else Expression.kron(*args)  # type: ignore\n</code></pre>"},{"location":"api/expressions/#qadence2_expressions.core.expression.visualize_expression","title":"<code>visualize_expression(expr)</code>","text":"<p>Stringfy expressions.</p> Source code in <code>qadence2_expressions/core/expression.py</code> <pre><code>def visualize_expression(expr: Expression) -&gt; str:\n    \"\"\"Stringfy expressions.\"\"\"\n\n    if expr.is_value or expr.is_symbol:\n        return str(expr[0])\n\n    if expr.is_quantum_operator:\n        dag = \"\\u2020\" if expr.get(\"is_dagger\") else \"\"\n        if expr[0].is_symbol or expr[0].is_function:\n            return f\"{expr[0]}{dag}{expr[1]}\"\n        return f\"{expr[0]}\"\n\n    if expr.is_function:\n        args = \",\\u2009\".join(map(str, expr[1:]))\n        return f\"{expr[0]}({args})\"\n\n    if expr.is_multiplication:\n        result = visualize_sequence(expr, \"\\u2009*\\u2009\")\n        return sub(r\"-1\\.0(\\s\\*)?\\s\", \"-\", result)\n\n    if expr.is_kronecker_product:\n        return visualize_sequence(expr, \"\\u2009*\\u2009\")\n\n    if expr.is_addition:\n        result = visualize_sequence(expr, \" + \", with_brackets=False)\n        return sub(r\"\\s\\+\\s-(1\\.0(\\s\\*)?\\s)?\", \" - \", result)\n\n    if expr.is_power:\n        return visualize_sequence(expr, \"\\u2009^\\u2009\")\n\n    return repr(expr)\n</code></pre>"},{"location":"api/expressions/#qadence2_expressions.core.expression.visualize_sequence","title":"<code>visualize_sequence(expr, operator, with_brackets=True)</code>","text":"<p>Stringfy the arguments of an expression <code>expr</code> with the designed <code>operator</code>.</p> <p>The <code>with_brackets</code> option wrap any argument that is either a multiplication or a sum.</p> Source code in <code>qadence2_expressions/core/expression.py</code> <pre><code>def visualize_sequence(expr: Expression, operator: str, with_brackets: bool = True) -&gt; str:\n    \"\"\"Stringfy the arguments of an expression `expr` with the designed `operator`.\n\n    The `with_brackets` option wrap any argument that is either a multiplication or a sum.\n    \"\"\"\n\n    if expr.is_value or expr.is_symbol or (expr.is_quantum_operator and expr[0].is_symbol):\n        raise SyntaxError(\"Only a sequence of expressions is allowed.\")\n\n    if with_brackets:\n        return operator.join(map(visualize_with_brackets, expr.args))\n\n    return operator.join(map(str, expr.args))\n</code></pre>"},{"location":"api/expressions/#qadence2_expressions.core.expression.visualize_with_brackets","title":"<code>visualize_with_brackets(expr)</code>","text":"<p>Stringfy addition and multiplication expression surrounded by brackets.</p> Source code in <code>qadence2_expressions/core/expression.py</code> <pre><code>def visualize_with_brackets(expr: Expression) -&gt; str:\n    \"\"\"Stringfy addition and multiplication expression surrounded by brackets.\"\"\"\n\n    if expr.is_multiplication or expr.is_addition:\n        return f\"({str(expr)})\"\n\n    return str(expr)\n</code></pre>"},{"location":"api/support/","title":"Support","text":""},{"location":"api/support/#the-support-module","title":"The <code>support</code> module","text":"<p>The <code>support</code> module defines a <code>Support</code> type to handle qubit support for single, multi and controlled quantum operations.</p>"},{"location":"api/support/#qadence2_expressions.core.support.Support","title":"<code>Support(*indices, target=None, control=None)</code>","text":"<p>A class to handle the qubit support providing easy initialization for single, multi, and controlled qubit operations.</p> <p>The class can be initialized in three ways:</p> <ol> <li><code>Support(i)</code> for single qubit support.</li> <li><code>Support(i\u2080,...,i\u2099)</code> for supports covering indices <code>{i\u2080,...,i\u2099}</code> use either by multi-indices     operation or to span single indices operations over multiple indices.</li> <li><code>Support(target=(i\u2080,...), control=(j\u2080,...))</code> for controled operations where <code>target</code> and     <code>control</code> are disjoint sets.</li> </ol> PARAMETER DESCRIPTION <code>indices</code> <p>Qubit indices where an operation is applied; all listed qubits are the target qubits.</p> <p> TYPE: <code>int</code> DEFAULT: <code>()</code> </p> <code>target</code> <p>Tuple of qubit indices where a given operation is applied; not valid if <code>indices</code> is defined.</p> <p> TYPE: <code>tuple[int, ...] | None</code> DEFAULT: <code>None</code> </p> <code>control</code> <p>Tuple of qubit indices used to control an operation; not valid without <code>target</code>.</p> <p> TYPE: <code>tuple[int, ...] | None</code> DEFAULT: <code>None</code> </p> METHOD DESCRIPTION <code>`subspace`</code> <p>returns the set of indices covered by the support.</p> <code>`overlap_with`</code> <p>returns true if a support overlaps with another (not distinguishing between target and controls).</p> <code>`join`</code> <p>merge two supports.</p> Source code in <code>qadence2_expressions/core/support.py</code> <pre><code>def __init__(\n    self,\n    *indices: int,\n    target: tuple[int, ...] | None = None,\n    control: tuple[int, ...] | None = None,\n) -&gt; None:\n    if indices and (target or control):\n        raise SyntaxError(\"Please, provide either qubit indices or target-control tuples\")\n\n    if control and not target:\n        raise SyntaxError(\"A controlled operation needs both, control and target.\")\n\n    if indices:\n        target = tuple(sorted(indices))\n        control = ()\n    else:\n        if target and control and set(target) &amp; set(control):\n            raise SyntaxError(\"Target and control indices cannot overlap.\")\n\n        target = tuple(sorted(target)) if target else ()\n        control = tuple(sorted(control)) if control else ()\n\n    self._subspace: tuple[int, ...] = (*target, *control)\n    self._control_start = len(target)\n</code></pre>"},{"location":"api/support/#qadence2_expressions.core.support.Support.control","title":"<code>control: tuple[int, ...]</code>  <code>property</code>","text":"<p>Returns the indices used to control a given operation.</p>"},{"location":"api/support/#qadence2_expressions.core.support.Support.max_index","title":"<code>max_index: int</code>  <code>cached</code> <code>property</code>","text":"<p>Returns the largest index within the specified subspace, whether it is a target or control. If the support is applied to all qubits, it returns <code>-1</code>.</p>"},{"location":"api/support/#qadence2_expressions.core.support.Support.subspace","title":"<code>subspace: set[int]</code>  <code>cached</code> <code>property</code>","text":"<p>Returns a set containing all the indices covered by the support.</p>"},{"location":"api/support/#qadence2_expressions.core.support.Support.target","title":"<code>target: tuple[int, ...]</code>  <code>property</code>","text":"<p>Returns the indices to which a given operation is applied.</p>"},{"location":"api/support/#qadence2_expressions.core.support.Support.__lt__","title":"<code>__lt__(other)</code>","text":"<p>Implement partial order to qubit supports.</p> Source code in <code>qadence2_expressions/core/support.py</code> <pre><code>def __lt__(self, other: object) -&gt; bool:\n    \"\"\"Implement partial order to qubit supports.\"\"\"\n\n    if not isinstance(other, Support):\n        return NotImplemented\n\n    return self._subspace &lt; other._subspace\n</code></pre>"},{"location":"api/support/#qadence2_expressions.core.support.Support.join","title":"<code>join(other)</code>","text":"<p>Merge two support's indices according the following rules.</p> <ol> <li> <p>If one of the supports cover all the indices, the result also covers    all the indices.</p> </li> <li> <p>If the target of one support overlaps with the control of the other    support, the resul is a support which the target covers all the    indices without target.</p> </li> <li> <p>Otherwise, the targets and the controls are merged.</p> </li> </ol> Source code in <code>qadence2_expressions/core/support.py</code> <pre><code>def join(self, other: Support) -&gt; Support:\n    \"\"\"Merge two support's indices according the following rules.\n\n    1. If one of the supports cover all the indices, the result also covers\n       all the indices.\n\n    2. If the target of one support overlaps with the control of the other\n       support, the resul is a support which the target covers all the\n       indices without target.\n\n    3. Otherwise, the targets and the controls are merged.\n    \"\"\"\n\n    # If one of the supports covers all the indices, the join will also do.\n    if not (self.target and other.target):\n        return Support()\n\n    target = set(self.target) | set(other.target)\n    control = set(self.control) | set(other.control)\n    overlap = target &amp; control\n\n    if overlap:\n        return Support(target=tuple(target | control))\n\n    return Support(target=tuple(target), control=tuple(control))\n</code></pre>"},{"location":"api/support/#qadence2_expressions.core.support.Support.overlap_with","title":"<code>overlap_with(other)</code>","text":"<p>Returns true if both supports cover common indices.</p> Source code in <code>qadence2_expressions/core/support.py</code> <pre><code>def overlap_with(self, other: Support) -&gt; bool:\n    \"\"\"Returns true if both supports cover common indices.\"\"\"\n\n    # A support applied to all indices overlaps with any support.\n    if not (self.target and other.target):\n        return True\n\n    # Check the overlap bewtween the subspace and convert non-empty result to `True`, or `False`\n    # otherwise.\n    return bool(self.subspace &amp; other.subspace)\n</code></pre>"},{"location":"api/support/#qadence2_expressions.core.support.Support.target_all","title":"<code>target_all()</code>  <code>classmethod</code>","text":"<p>Return a support that covers all qubits, regardless of range or total number of qubits.</p> Source code in <code>qadence2_expressions/core/support.py</code> <pre><code>@classmethod\ndef target_all(cls) -&gt; Support:\n    \"\"\"Return a support that covers all qubits, regardless of range or total number of\n    qubits.\n    \"\"\"\n    return cls()\n</code></pre>"},{"location":"contents/expression_system/","title":"Expression system","text":"<p>Qadence 2 Expression system is designed to create expressive, self-contained and abstract symbolic expressions to represent quantum programs in the digital-analog paradigm. These expressions can be transpiled later with concretized and specific data types, such as <code>numpy</code>, <code>pytorch</code> and <code>jax</code> for execution on targeted backends.</p> <p>The Expression system defines syntactic rules to generate symbolic quantum expressions, that can contain parametric expressions for parameters (static, <code>FeatureParameter</code>) and variables (dynamic, <code>VariationalParameter</code>) to be used for training purposes. Expression composition can be seamlessly applied to quantum operators for digital, analog and digital-analog computations. It also supports arithmetic operations for both classical and quantum expressions as well as reduction, simplification and replacement methods.</p>"},{"location":"contents/expression_system/#symbolic-manipulation","title":"Symbolic manipulation","text":"<p>In these examples, basic arithmetic expressions on symbols (parameters) are evaluated to illustrate simplifications and reductions.</p> <pre><code>from qadence2_expressions import *\n\na = parameter('a')\nb = parameter('b')\n</code></pre> <pre><code>a + a \u2192 2.0\u2009*\u2009a\na - a \u2192 0.0\na / a \u2192 1.0\na + b \u2192 a + b\na / (2*b) \u2192 a\u2009*\u2009(2.0\u2009*\u2009b)\u2009^\u2009-1.0\na ** 0 \u2192 1.0\na ** 1 \u2192 a\n2 ** (a + b' \u2192 2.0\u2009^\u2009(a + b)\n</code></pre> <p>Products of sums are expanded</p> <pre><code>(a + b) * (a + b)\n</code></pre> <pre><code>\u2192 a\u2009^\u20092.0 + 2.0\u2009*\u2009a\u2009*\u2009b + b\u2009^\u20092.0\n</code></pre> <p>But exponentiations of sums are not as power simplifications take precedence.</p> <pre><code>(a + b) * (a + b) ** 2 / (a + b)\n</code></pre> <pre><code>\u2192 (a + b)\u2009^\u20092.0\n</code></pre>"},{"location":"contents/expression_system/#quantum-operators","title":"Quantum operators","text":"<p>Standard quantum operators are defined as Python <code>Callable</code> that accept a qubit support as argument. Please note that the support can either be a single <code>int</code> for single qubit operations or a tuple of qubit indices for operations that span across multiple qubits or nothing to create global operations that span across the whole register (denoted by the <code>*</code> wildcard).</p> <pre><code>X(2) * Y() * Z(1,2)\n</code></pre> <pre><code>\u2192 X[2]\u2009*\u2009Y[*]\u2009*\u2009Z[1,2]\n</code></pre> <p>(Multi-)Controlled operators need to be provided with non-overlapping tuples for control and target qubits. The notation convention is to display target indices first followed by control indices in increasing ordering.</p> <pre><code>NOT(control=(1,), target=(2,)) * NOT(target=(1,3), control=(2,4))\n</code></pre> <pre><code>\u2192 NOT[2|1]\u2009*\u2009NOT[1,3|2,4]\n</code></pre> <p>Quantum operators can be parametrized and expressions expanded.</p> <pre><code>X() * (cos(a) * X() + 1j * sin(a) * Y()) / 2\n</code></pre> <pre><code>\u2192 0.5\u2009*\u2009cos(a) + 0.5j\u2009*\u2009sin(a)\u2009*\u2009X[*]\u2009*\u2009Y[*]\n</code></pre> <p>Global and local operators can be combined.</p> <pre><code>X(1) * (cos(a) * X() + 1j * sin(a) * Y()) * Z(1) / 2\n</code></pre> <pre><code>\u2192 0.5\u2009*\u2009cos(a)\u2009*\u2009X[1]\u2009*\u2009X[*]\u2009*\u2009Z[1] + 0.5j\u2009*\u2009sin(a)\u2009*\u2009X[1]\u2009*\u2009Y[*]\u2009*\u2009Z[1]\n</code></pre> <p>Custom operators can be created as functions or based on other operators. For instance, the <code>CNOT</code>:</p> <pre><code>CNOT = lambda ctrl, tgt: NOT(target=(tgt,), control=(ctrl,))\nY(4) * X(3) * Y(5,4) * CNOT(1,2) * Z(3)\n</code></pre> <pre><code>\u2192 NOT[2|1]\u2009*\u2009X[3]\u2009*\u2009Z[3]\u2009*\u2009Y[4]\u2009*\u2009Y[4,5]\n</code></pre> <p>Or the number operator. Expansion rules still hold.</p> <pre><code>N = lambda k: (1 - Z(k)) / 2\n\nsum(a * X(i) - b * Z(i) + N(i) * N(i + 1) for i in range(1))\n</code></pre> <pre><code>\u2192 0.25 + a\u2009*\u2009X[0] - b\u2009*\u2009Z[0] - 0.25\u2009*\u2009Z[1] - 0.25\u2009*\u2009Z[0] + 0.25\u2009*\u2009Z[0]\u2009*\u2009Z[1]\n</code></pre> <p>Parametric operators need to get passed a parameter as first argument, then the qubit support. This ensures syntactic consistency across operators. Unitarity still holds.</p> <pre><code>phi = variable(\"phi\")\n\nRX(phi / 2)(1) * RX(phi / 2)(1).dag\n</code></pre> <pre><code>\u2192 1.0\n</code></pre> <p>Arithmetic operations still hold for operator parameters defined over the same support.</p> <pre><code>RX(phi / 2)(1) * RX(- phi / 2)(1)\n</code></pre> <pre><code>\u2192 1.0\n</code></pre> <p>As opposed to:</p> <pre><code>RX(phi / 2)(1) * RX(phi / 2)(2).dag\n</code></pre> <pre><code>\u2192 RX(0.5\u2009*\u2009phi)[1]\u2009*\u2009RX(0.5\u2009*\u2009phi)\u2020[2]\n</code></pre>"},{"location":"contents/ir_compilation/","title":"Intermediate Representation compilation","text":"<p>Qadence 2 expression package provides compilation functionality to target Qadence 2 Intermediate Representation (IR) defined here. Please note that the IR follows SSA form for classical computations.</p> <p>In following is a pure digital program with local possibly parametrized gates compiled to the IR model.</p> <pre><code>from qadence2_expressions import *\n\na = parameter('a')\nb = parameter('b')\n\nphi = variable(\"phi\")\n\nexpr = RX(a * phi / 2)(2) * Z(1) * RY(b * phi / 2)(0)\n\nreset_ir_options()\nir = compile_to_model(expr)\n</code></pre> <pre><code>Model(\n  AllocQubits(3),\n  {\n    'b': Alloc(1, trainable=False),\n    'phi': Alloc(1, trainable=True),\n    'a': Alloc(1, trainable=False),\n  },\n  [\n    Assign('%0', Call('mul', 0.5, Load('b'))),\n    Assign('%1', Call('mul', Load('%0'), Load('phi'))),\n    QuInstruct('ry', Support((0,)), Load('%1')),\n    QuInstruct('z', Support((1,))),\n    Assign('%2', Call('mul', 0.5, Load('a'))),\n    Assign('%3', Call('mul', Load('%2'), Load('phi'))),\n    QuInstruct('rx', Support((2,)), Load('%3')),\n  ]\n)\n</code></pre> <p>Similar example with interleaved global gates.</p> <pre><code>expr = RX(a * phi / 2)(2) * CZ() * RY(b * phi / 2)(0)\n\nir = compile_to_model(expr)\n</code></pre> <pre><code>Model(\n  AllocQubits(3),\n  {\n    'a': Alloc(1, trainable=False),\n    'phi': Alloc(1, trainable=True),\n    'b': Alloc(1, trainable=False),\n  },\n  [\n    Assign('%0', Call('mul', 0.5, Load('a'))),\n    Assign('%1', Call('mul', Load('%0'), Load('phi'))),\n    QuInstruct('rx', Support((2,)), Load('%1')),\n    QuInstruct('cz', Support.target_all()),\n    Assign('%2', Call('mul', 0.5, Load('b'))),\n    Assign('%3', Call('mul', Load('%2'), Load('phi'))),\n    QuInstruct('ry', Support((0,)), Load('%3')),\n  ]\n)\n</code></pre> <p>Options can be set at any point to supplement the model to be recompiled.</p> <pre><code>set_qubits_positions([(-2, 1), (0, 0), (3, 1)])\nset_grid_type(\"triangular\")\n\nir = compile_to_model(expr)\n</code></pre> <pre><code>Model(\n  AllocQubits(3, qubit_positions=[(-2, 1), (0, 0), (3, 1)], grid_type='triangular'),\n  {\n    'a': Alloc(1, trainable=False),\n    'phi': Alloc(1, trainable=True),\n    'b': Alloc(1, trainable=False),\n  },\n  [\n    Assign('%0', Call('mul', 0.5, Load('a'))),\n    Assign('%1', Call('mul', Load('%0'), Load('phi'))),\n    QuInstruct('rx', Support((2,)), Load('%1')),\n    QuInstruct('cz', Support.target_all()),\n    Assign('%2', Call('mul', 0.5, Load('b'))),\n    Assign('%3', Call('mul', Load('%2'), Load('phi'))),\n    QuInstruct('ry', Support((0,)), Load('%3')),\n  ]\n)\n</code></pre> <p>Pure analog programs can be constructed using <code>NativeDrive</code> and <code>FreeEvolution</code> operations that leave their concrete definitions and implementations to the backend. They can accept arbitrary combinations of single valued or arrays of parameters.</p> <pre><code>set_qubits_positions([(-1,0), (-1, 1), (1, 0), (1, 1)])\nset_grid_type(\"triangular\")\n\nt = variable(\"t\")\nomega = array_variable(\"omega\", 4)\ndetuning = array_variable(\"detuning\", 3)\nphase = parameter(\"phase\")\n\nexpr = (\n    NativeDrive(t / 2, omega, detuning, phase)()\n    * FreeEvolution(2.5)()\n    * NativeDrive(t / 2, omega, -detuning, phase)()\n)\n\nir = compile_to_model(expr)\n</code></pre> <pre><code>Model(\n  AllocQubits(4, qubit_positions=[(-1, 0), (-1, 1), (1, 0), (1, 1)], grid_type='triangular'),\n  {\n    't': Alloc(1, trainable=True),\n    'omega': Alloc(4, trainable=True),\n    'detuning': Alloc(3, trainable=True),\n    'phase': Alloc(1, trainable=False),\n  },\n  [\n    Assign('%0', Call('mul', 0.5, Load('t'))),\n    QuInstruct('dyn_pulse', Support.target_all(), Load('%0'), Load('omega'), Load('detuning'), Load('phase')),\n    QuInstruct('dyn_wait', Support.target_all(), 2.5),\n    Assign('%1', Call('mul', -1.0, Load('detuning'))),\n    QuInstruct('dyn_pulse', Support.target_all(), Load('%0'), Load('omega'), Load('%1'), Load('phase')),\n  ]\n)\n</code></pre>"},{"location":"contents/useful_functions/","title":"Useful functions","text":"<p>Currently, there are two useful methods for querying and manipulating expressions, namely <code>collect_operators</code> and <code>replace</code>. In following are examples for each.</p> <pre><code>from qadence2_expressions import *\n\ncollected_ops = collect_operators(Z(1) + 2 * Z(1) * Z (2) - X(3))\n</code></pre> <pre><code>{QuantumOperator(Symbol('Z'), [1], is_hermitian=True, is_unitary=True): Value(1.0), KroneckerProduct(QuantumOperator(Symbol('Z'), [1], is_hermitian=True, is_unitary=True), QuantumOperator(Symbol('Z'), [2], is_hermitian=True, is_unitary=True)): Value(2.0), QuantumOperator(Symbol('X'), [3], is_hermitian=True, is_unitary=True): Value(-1.0)}\n</code></pre> <pre><code>replacement_rules = {Z(1): X(1)}\n\nreplaced_ops = replace(Z(1) + 2 * Z(1) * Z (2) - X(3), replacement_rules)\n</code></pre> <pre><code>\u2192 X[1] + 2.0\u2009*\u2009X[1]\u2009*\u2009Z[2] - X[3]\n</code></pre>"},{"location":"getting_started/CODE_OF_CONDUCT/","title":"Code of Conduct","text":""},{"location":"getting_started/CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"getting_started/CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a professional setting</li> </ul>"},{"location":"getting_started/CODE_OF_CONDUCT/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"getting_started/CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"getting_started/CONTRIBUTING/","title":"How to contribute","text":"<p>We're grateful for your interest in participating in Qadence 2 Expressions. Please follow our guidelines to ensure a smooth contribution process.</p>"},{"location":"getting_started/CONTRIBUTING/#reporting-an-issue-or-proposing-a-feature","title":"Reporting an issue or proposing a feature","text":"<p>Your course of action will depend on your objective, but generally, you should start by creating an issue. If you've discovered a bug or have a feature you'd like to see added to qadence expressions, feel free to create an issue on qadence expression's GitHub issue tracker. Here are some steps to take:</p> <ol> <li>Quickly search the existing issues using relevant keywords to ensure your issue hasn't been addressed already.</li> <li> <p>If your issue is not listed, create a new one. Try to be as detailed and clear as possible in your description.</p> </li> <li> <p>If you're merely suggesting an improvement or reporting a bug, that's already excellent! We thank you for it. Your issue will be listed and, hopefully, addressed at some point.</p> </li> <li>However, if you're willing to be the one solving the issue, that would be even better! In such instances, you would proceed by preparing a Pull Request.</li> </ol>"},{"location":"getting_started/CONTRIBUTING/#submitting-a-pull-request","title":"Submitting a pull request","text":"<p>We're excited that you're eager to contribute to Qadence Expressions. To contribute, fork the <code>main</code> branch of qadence expressions repository and once you are satisfied with your feature and all the tests pass create a Pull Request.</p> <p>Here's the process for making a contribution:</p> <p>Click the \"Fork\" button in the upper right corner of the repo page to create a new GitHub repo at <code>https://github.com/USERNAME/wip-qadence2-expressions</code>, where <code>USERNAME</code> is your GitHub ID. Then, <code>cd</code> into the directory where you want to place your new fork and clone it:</p> <pre><code>git clone https://github.com/USERNAME/wip-qadence2-expressions.git\n</code></pre> <p>Next, navigate to your new qadence expressions fork directory and mark the main qadence expressions repository as the <code>upstream</code>:</p> <pre><code>git remote add upstream https://github.com/pasqal-io/wip-qadence2-expressions.git\n</code></pre>"},{"location":"getting_started/CONTRIBUTING/#setting-up-your-development-environment","title":"Setting up your development environment","text":"<p>We recommended to use <code>hatch</code> for managing environments:</p> <p>To develop within qadence expressions, use: <pre><code>pip install hatch\nhatch -v shell\n</code></pre></p> <p>To run qadence expressions tests, use:</p> <pre><code>hatch -e tests run test\n</code></pre> <p>If you don't want to use <code>hatch</code>, you can use the environment manager of your choice (e.g. Conda) and execute the following:</p> <pre><code>pip install pytest\npip install -e .\npytest\n</code></pre>"},{"location":"getting_started/CONTRIBUTING/#linting-and-testing-workflows","title":"Linting and testing workflows","text":"<p>Use <code>pre-commit</code> to lint your code and run the unit tests before pushing a new commit.</p> <p>Using <code>hatch</code>, it's simply:</p> <pre><code>hatch -e tests run pre-commit run --all-files\nhatch -e tests run test\n</code></pre> <p>Our CI/CD pipeline will also test if the documentation can be built correctly. To test it locally, please run:</p> <pre><code>hatch -e docs run mkdocs build --clean --strict\n</code></pre> <p>Without <code>hatch</code>, <code>pip</code> install those libraries first: \"mkdocs\", \"mkdocs-material\", \"mkdocstrings\", \"mkdocstrings-python\", \"mkdocs-section-index\", \"mkdocs-jupyter\", \"mkdocs-exclude\", \"markdown-exec\"</p> <p>And then:</p> <pre><code> mkdocs build --clean --strict\n</code></pre>"},{"location":"getting_started/LICENSE/","title":"Apache License","text":"<p>Version 2.0, January 2004</p> <p>http://www.apache.org/licenses/</p>"},{"location":"getting_started/LICENSE/#terms-and-conditions-for-use-reproduction-and-distribution","title":"TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION","text":""},{"location":"getting_started/LICENSE/#1-definitions","title":"1. Definitions:","text":"<p>\"License\" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document.</p> <p>\"Licensor\" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License.</p> <p>\"Legal Entity\" shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity.</p> <p>\"You\" (or \"Your\") shall mean an individual or Legal Entity exercising permissions granted by this License.</p> <p>\"Source\" form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files.</p> <p>\"Object\" form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types.</p> <p>\"Work\" shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below).</p> <p>\"Derivative Works\" shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof.</p> <p>\"Contribution\" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \"submitted\" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \"Not a Contribution.\"</p> <p>\"Contributor\" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work.</p>"},{"location":"getting_started/LICENSE/#2-grant-of-copyright-license","title":"2. Grant of Copyright License.","text":"<p>Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form.</p>"},{"location":"getting_started/LICENSE/#3-grant-of-patent-license","title":"3. Grant of Patent License.","text":"<p>Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed.</p>"},{"location":"getting_started/LICENSE/#4-redistribution","title":"4. Redistribution.","text":"<p>You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions:</p> <ul> <li> <p>(a) You must give any other recipients of the Work or       Derivative Works a copy of this License; and</p> </li> <li> <p>(b) You must cause any modified files to carry prominent notices       stating that You changed the files; and</p> </li> <li> <p>(c) You must retain, in the Source form of any Derivative Works       that You distribute, all copyright, patent, trademark, and       attribution notices from the Source form of the Work,       excluding those notices that do not pertain to any part of       the Derivative Works; and</p> </li> <li> <p>(d) If the Work includes a \"NOTICE\" text file as part of its       distribution, then any Derivative Works that You distribute must       include a readable copy of the attribution notices contained       within such NOTICE file, excluding those notices that do not       pertain to any part of the Derivative Works, in at least one       of the following places: within a NOTICE text file distributed       as part of the Derivative Works; within the Source form or       documentation, if provided along with the Derivative Works; or,       within a display generated by the Derivative Works, if and       wherever such third-party notices normally appear. The contents       of the NOTICE file are for informational purposes only and       do not modify the License. You may add Your own attribution       notices within Derivative Works that You distribute, alongside       or as an addendum to the NOTICE text from the Work, provided       that such additional attribution notices cannot be construed       as modifying the License.</p> </li> </ul> <p>You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License.</p>"},{"location":"getting_started/LICENSE/#5-submission-of-contributions","title":"5. Submission of Contributions.","text":"<p>Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions.</p>"},{"location":"getting_started/LICENSE/#6-trademarks","title":"6. Trademarks.","text":"<p>This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file.</p>"},{"location":"getting_started/LICENSE/#7-disclaimer-of-warranty","title":"7. Disclaimer of Warranty.","text":"<p>Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License.</p>"},{"location":"getting_started/LICENSE/#8-limitation-of-liability","title":"8. Limitation of Liability.","text":"<p>In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages.</p>"},{"location":"getting_started/LICENSE/#9-accepting-warranty-or-additional-liability","title":"9. Accepting Warranty or Additional Liability.","text":"<p>While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability.</p>"},{"location":"getting_started/LICENSE/#end-of-terms-and-conditions","title":"END OF TERMS AND CONDITIONS","text":""},{"location":"getting_started/installation/","title":"Installation","text":"<p>Note</p> <p>It is advised to set up a python environment before installing the package, such as venv, hatch, pyenv, conda or poetry. (Qadence 2 in development mode uses <code>hatch</code>).</p> <p>To install the current version of Qadence 2 Expressions, there are a few options:</p>"},{"location":"getting_started/installation/#installation-from-pypi","title":"Installation from PYPI","text":"<p>On the terminal, type</p> <pre><code>pip install qadence2-expressions\n</code></pre>"},{"location":"getting_started/installation/#installation-from-source","title":"Installation from Source","text":"<p>Clone this repository by typing on the terminal</p> <pre><code>git clone https://github.com/pasqal-io/qadence2-expressions.git\n</code></pre> <p>Go to <code>qadence2-expressions</code> folder and install it using hatch</p> <pre><code>hatch -v shell\n</code></pre> <p>Use hatch environment on your IDE or terminal to use <code>qadence2-expressions</code> package.</p>"},{"location":"tutorials/","title":"Tutorials","text":"<p>Warning</p> <p>This page is under construction.</p>"}]}